<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>let&#39;s build a simple interpreter 1(转)(翻) | Welcome to cbdshz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="让我们构建一个简单的解释器（1）原文链接：https://ruslanspivak.com/lsbasi-part1/  “If you don’t know compilers work,ten you don’t know how computers work. If you’re not 100% sure whether you know how compilers work,then y">
<meta property="og:type" content="article">
<meta property="og:title" content="let&#39;s build a simple interpreter 1(转)(翻)">
<meta property="og:url" content="http://yoursite.com/2019/03/01/HB-is-one-of-my-best-friends/index.html">
<meta property="og:site_name" content="Welcome to cbdshz">
<meta property="og:description" content="让我们构建一个简单的解释器（1）原文链接：https://ruslanspivak.com/lsbasi-part1/  “If you don’t know compilers work,ten you don’t know how computers work. If you’re not 100% sure whether you know how compilers work,then y">
<meta property="og:locale" content="1284911244@qq.com">
<meta property="og:image" content="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_i_dont_know.png">
<meta property="og:image" content="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_omg.png">
<meta property="og:image" content="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_i_know.png">
<meta property="og:image" content="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_compiler_interpreter.png">
<meta property="og:image" content="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_lexer1.png">
<meta property="og:image" content="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_lexer2.png">
<meta property="og:image" content="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_lexer3.png">
<meta property="og:image" content="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_lexer4.png">
<meta property="og:image" content="https://ruslanspivak.com/lsbasi-part1/lsbasi_exercises2.png">
<meta property="og:updated_time" content="2019-03-01T14:54:29.307Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="let&#39;s build a simple interpreter 1(转)(翻)">
<meta name="twitter:description" content="让我们构建一个简单的解释器（1）原文链接：https://ruslanspivak.com/lsbasi-part1/  “If you don’t know compilers work,ten you don’t know how computers work. If you’re not 100% sure whether you know how compilers work,then y">
<meta name="twitter:image" content="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_i_dont_know.png">
  
    <link rel="alternate" href="/atom.xml" title="Welcome to cbdshz" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Welcome to cbdshz</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/archives">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-HB-is-one-of-my-best-friends" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/01/HB-is-one-of-my-best-friends/" class="article-date">
  <time datetime="2019-02-28T16:28:52.000Z" itemprop="datePublished">2019-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      let&#39;s build a simple interpreter 1(转)(翻)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="让我们构建一个简单的解释器（1）"><a href="#让我们构建一个简单的解释器（1）" class="headerlink" title="让我们构建一个简单的解释器（1）"></a>让我们构建一个简单的解释器（1）</h2><p>原文链接：<a href="https://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener">https://ruslanspivak.com/lsbasi-part1/</a> </p>
<p><strong><em>“If you don’t know compilers work,ten you don’t know how computers work. If you’re not 100% sure whether you know how compilers work,then you don’t know how the work.”<br>–Steve Yegge</em></strong>  </p>
<h3 id="好吧，各位。想想上面这句话，无论你是一个菜鸟还是一个资深的软件开发工程师，如果你不懂编译器和解释器是如何工作的，那么你就不会知道计算机是如何工作的。这应该很容易理解。"><a href="#好吧，各位。想想上面这句话，无论你是一个菜鸟还是一个资深的软件开发工程师，如果你不懂编译器和解释器是如何工作的，那么你就不会知道计算机是如何工作的。这应该很容易理解。" class="headerlink" title="好吧，各位。想想上面这句话，无论你是一个菜鸟还是一个资深的软件开发工程师，如果你不懂编译器和解释器是如何工作的，那么你就不会知道计算机是如何工作的。这应该很容易理解。"></a>好吧，各位。想想上面这句话，无论你是一个菜鸟还是一个资深的软件开发工程师，如果你不懂编译器和解释器是如何工作的，那么你就不会知道计算机是如何工作的。这应该很容易理解。</h3><h3 id="所以，你知道编译器或者解释器是如何工作的吗？好吧，我的意思是你真的百分百确定你知道他是如何工作的吗？如果你不知道"><a href="#所以，你知道编译器或者解释器是如何工作的吗？好吧，我的意思是你真的百分百确定你知道他是如何工作的吗？如果你不知道" class="headerlink" title="所以，你知道编译器或者解释器是如何工作的吗？好吧，我的意思是你真的百分百确定你知道他是如何工作的吗？如果你不知道"></a>所以，你知道编译器或者解释器是如何工作的吗？好吧，我的意思是你真的百分百确定你知道他是如何工作的吗？如果你不知道</h3><p><img src="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_i_dont_know.png" alt="I don&#39;t"></p>
<h3 id="或者你知道并因此而感到焦虑"><a href="#或者你知道并因此而感到焦虑" class="headerlink" title="或者你知道并因此而感到焦虑"></a>或者你知道并因此而感到焦虑</h3><p><img src="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_omg.png" alt="OMG"></p>
<h3 id="不要担心。如果你能够坚持走完这一系列的学习并且和我一起构建一个解释器和编译器，那么最后你就能够知道它们是怎么工作的。同时，我也希望因此你能够感到快乐且增加自信。"><a href="#不要担心。如果你能够坚持走完这一系列的学习并且和我一起构建一个解释器和编译器，那么最后你就能够知道它们是怎么工作的。同时，我也希望因此你能够感到快乐且增加自信。" class="headerlink" title="不要担心。如果你能够坚持走完这一系列的学习并且和我一起构建一个解释器和编译器，那么最后你就能够知道它们是怎么工作的。同时，我也希望因此你能够感到快乐且增加自信。"></a>不要担心。如果你能够坚持走完这一系列的学习并且和我一起构建一个解释器和编译器，那么最后你就能够知道它们是怎么工作的。同时，我也希望因此你能够感到快乐且增加自信。</h3><p><img src="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_i_know.png" alt="happy"></p>
<h3 id="我们为什么要学习解释器和编译器？我将会给出以下三个理由。"><a href="#我们为什么要学习解释器和编译器？我将会给出以下三个理由。" class="headerlink" title="我们为什么要学习解释器和编译器？我将会给出以下三个理由。"></a>我们为什么要学习解释器和编译器？我将会给出以下三个理由。</h3><h4 id="1-编写一个解释器或编译器，需要结合使用大量的专业技能。编写解释器和编译器，将会帮助你提高那些专业技能并且成为一个更好地软件开发者。这些你通过这种方式学到的技能，将会对你写任何软件都将有所帮助，而不仅仅只限于解释器或编译器。"><a href="#1-编写一个解释器或编译器，需要结合使用大量的专业技能。编写解释器和编译器，将会帮助你提高那些专业技能并且成为一个更好地软件开发者。这些你通过这种方式学到的技能，将会对你写任何软件都将有所帮助，而不仅仅只限于解释器或编译器。" class="headerlink" title="1.编写一个解释器或编译器，需要结合使用大量的专业技能。编写解释器和编译器，将会帮助你提高那些专业技能并且成为一个更好地软件开发者。这些你通过这种方式学到的技能，将会对你写任何软件都将有所帮助，而不仅仅只限于解释器或编译器。"></a>1.编写一个解释器或编译器，需要结合使用大量的专业技能。编写解释器和编译器，将会帮助你提高那些专业技能并且成为一个更好地软件开发者。这些你通过这种方式学到的技能，将会对你写任何软件都将有所帮助，而不仅仅只限于解释器或编译器。</h4><h4 id="2-你真的非常想要知道计算机是如何工作的。解释器和编译器经常被视为一种魔术，而你不应该满足于简单运用它们。你想要揭开解释器和编译器的面纱，并且能够熟练运用它们。"><a href="#2-你真的非常想要知道计算机是如何工作的。解释器和编译器经常被视为一种魔术，而你不应该满足于简单运用它们。你想要揭开解释器和编译器的面纱，并且能够熟练运用它们。" class="headerlink" title="2.你真的非常想要知道计算机是如何工作的。解释器和编译器经常被视为一种魔术，而你不应该满足于简单运用它们。你想要揭开解释器和编译器的面纱，并且能够熟练运用它们。"></a>2.你真的非常想要知道计算机是如何工作的。解释器和编译器经常被视为一种魔术，而你不应该满足于简单运用它们。你想要揭开解释器和编译器的面纱，并且能够熟练运用它们。</h4><h4 id="3-你想要创造一个你自己的编程语言或者领域特定语言。如果你创造了一个语言，那么你也就需要为这种语言编写一个解释器或编译器。最近，新型编程语言的研究又引起了一大波热潮。你甚至几乎每天都能够看到一种新型语言蹦出来，比如Elixir、Go、Rust等。"><a href="#3-你想要创造一个你自己的编程语言或者领域特定语言。如果你创造了一个语言，那么你也就需要为这种语言编写一个解释器或编译器。最近，新型编程语言的研究又引起了一大波热潮。你甚至几乎每天都能够看到一种新型语言蹦出来，比如Elixir、Go、Rust等。" class="headerlink" title="3.你想要创造一个你自己的编程语言或者领域特定语言。如果你创造了一个语言，那么你也就需要为这种语言编写一个解释器或编译器。最近，新型编程语言的研究又引起了一大波热潮。你甚至几乎每天都能够看到一种新型语言蹦出来，比如Elixir、Go、Rust等。"></a>3.你想要创造一个你自己的编程语言或者领域特定语言。如果你创造了一个语言，那么你也就需要为这种语言编写一个解释器或编译器。最近，新型编程语言的研究又引起了一大波热潮。你甚至几乎每天都能够看到一种新型语言蹦出来，比如Elixir、Go、Rust等。</h4><h3 id="好了，那么解释器和编译器到底是什么呢？"><a href="#好了，那么解释器和编译器到底是什么呢？" class="headerlink" title="好了，那么解释器和编译器到底是什么呢？"></a>好了，那么解释器和编译器到底是什么呢？</h3><h3 id="一个解释器和编译器的目标就是将用高级语言编写的源程序翻译成另一种形式。是不是解释的相当含糊？再忍耐一下吧，之后的文章中，你就会学到如何将源程序进行翻译的了。"><a href="#一个解释器和编译器的目标就是将用高级语言编写的源程序翻译成另一种形式。是不是解释的相当含糊？再忍耐一下吧，之后的文章中，你就会学到如何将源程序进行翻译的了。" class="headerlink" title="一个解释器和编译器的目标就是将用高级语言编写的源程序翻译成另一种形式。是不是解释的相当含糊？再忍耐一下吧，之后的文章中，你就会学到如何将源程序进行翻译的了。"></a>一个解释器和编译器的目标就是将用高级语言编写的源程序翻译成另一种形式。是不是解释的相当含糊？再忍耐一下吧，之后的文章中，你就会学到如何将源程序进行翻译的了。</h3><h3 id="在这里，就让我先来解释一下编译器和解释器到底有什么区别吧。如果一个翻译器将源程序代码翻译成机器语言，那么这就是一个编译器。如果一个翻译器没有将源代码翻译成机器语言，就处理并且运行了源代码，那么这就是一个解释器。大概看起来就如下图所示："><a href="#在这里，就让我先来解释一下编译器和解释器到底有什么区别吧。如果一个翻译器将源程序代码翻译成机器语言，那么这就是一个编译器。如果一个翻译器没有将源代码翻译成机器语言，就处理并且运行了源代码，那么这就是一个解释器。大概看起来就如下图所示：" class="headerlink" title="在这里，就让我先来解释一下编译器和解释器到底有什么区别吧。如果一个翻译器将源程序代码翻译成机器语言，那么这就是一个编译器。如果一个翻译器没有将源代码翻译成机器语言，就处理并且运行了源代码，那么这就是一个解释器。大概看起来就如下图所示："></a>在这里，就让我先来解释一下编译器和解释器到底有什么区别吧。如果一个翻译器将源程序代码翻译成机器语言，那么这就是一个编译器。如果一个翻译器没有将源代码翻译成机器语言，就处理并且运行了源代码，那么这就是一个解释器。大概看起来就如下图所示：</h3><p><img src="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_compiler_interpreter.png" alt="compiler and interpreter"></p>
<h3 id="我希望到现在为止你很确信你真的想要学习并且构建一个解释器和编译器。那么你可以从这一个关于解释器的系列中的学习到什么呢？"><a href="#我希望到现在为止你很确信你真的想要学习并且构建一个解释器和编译器。那么你可以从这一个关于解释器的系列中的学习到什么呢？" class="headerlink" title="我希望到现在为止你很确信你真的想要学习并且构建一个解释器和编译器。那么你可以从这一个关于解释器的系列中的学习到什么呢？"></a>我希望到现在为止你很确信你真的想要学习并且构建一个解释器和编译器。那么你可以从这一个关于解释器的系列中的学习到什么呢？</h3><h3 id="直说吧，我打算一起去为Pascal语言的一个大子集实现一个简单的解释器。在这一系列的最后，你将会拥有一个Pascal的解释器，这个解释器还能够从源代码级别进行调试，就像Python的pdb一样。"><a href="#直说吧，我打算一起去为Pascal语言的一个大子集实现一个简单的解释器。在这一系列的最后，你将会拥有一个Pascal的解释器，这个解释器还能够从源代码级别进行调试，就像Python的pdb一样。" class="headerlink" title="直说吧，我打算一起去为Pascal语言的一个大子集实现一个简单的解释器。在这一系列的最后，你将会拥有一个Pascal的解释器，这个解释器还能够从源代码级别进行调试，就像Python的pdb一样。"></a>直说吧，我打算一起去为<a href="https://en.wikipedia.org/wiki/Pascal_%28programming_language%29" target="_blank" rel="noopener">Pascal</a>语言的一个大子集实现一个简单的解释器。在这一系列的最后，你将会拥有一个Pascal的解释器，这个解释器还能够从源代码级别进行调试，就像Python的<a href="https://docs.python.org/2/library/pdb.html" target="_blank" rel="noopener">pdb</a>一样。</h3><h3 id="你可能会问，为什么是Pascal？首先，这不是一个虚无的语言，所以我选择它在这个系列中使用：这是一个真实使用的编程语言并且拥有许多重要语言结构。虽然有些老，却非常实用，CS书籍使用Pascal编程语言作为他们的示范样例（虽然这个理由不是很充分，但是我想这也是一个学习一种非主流语言的好机会）。"><a href="#你可能会问，为什么是Pascal？首先，这不是一个虚无的语言，所以我选择它在这个系列中使用：这是一个真实使用的编程语言并且拥有许多重要语言结构。虽然有些老，却非常实用，CS书籍使用Pascal编程语言作为他们的示范样例（虽然这个理由不是很充分，但是我想这也是一个学习一种非主流语言的好机会）。" class="headerlink" title="你可能会问，为什么是Pascal？首先，这不是一个虚无的语言，所以我选择它在这个系列中使用：这是一个真实使用的编程语言并且拥有许多重要语言结构。虽然有些老，却非常实用，CS书籍使用Pascal编程语言作为他们的示范样例（虽然这个理由不是很充分，但是我想这也是一个学习一种非主流语言的好机会）。"></a>你可能会问，为什么是Pascal？首先，这不是一个虚无的语言，所以我选择它在这个系列中使用：这是一个真实使用的编程语言并且拥有许多重要语言结构。虽然有些老，却非常实用，CS书籍使用Pascal编程语言作为他们的示范样例（虽然这个理由不是很充分，但是我想这也是一个学习一种非主流语言的好机会）。</h3><h3 id="这里是一个使用Pascal的阶乘函数。通过你自己的解释器，你将能够解释执行并且进行调试源代码程序："><a href="#这里是一个使用Pascal的阶乘函数。通过你自己的解释器，你将能够解释执行并且进行调试源代码程序：" class="headerlink" title="这里是一个使用Pascal的阶乘函数。通过你自己的解释器，你将能够解释执行并且进行调试源代码程序："></a>这里是一个使用Pascal的阶乘函数。通过你自己的解释器，你将能够解释执行并且进行调试源代码程序：</h3><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> factorial;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(n: integer)</span>:</span> longint;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> n = <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        factorial := <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        factorial := n * factorial(n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    n: integer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span> <span class="keyword">to</span> <span class="number">16</span> <span class="keyword">do</span></span><br><span class="line">        writeln(n, <span class="string">'! = '</span>, factorial(n));</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<h3 id="我们实现Pascal解释器的语言将会是Python，但是你能够使用任何语言，因为解释器的实现并不依赖于语言的特性。Okay，该开始着手正事了。预备，开始！（翻译者在学习时也使用JAVA再次实现）"><a href="#我们实现Pascal解释器的语言将会是Python，但是你能够使用任何语言，因为解释器的实现并不依赖于语言的特性。Okay，该开始着手正事了。预备，开始！（翻译者在学习时也使用JAVA再次实现）" class="headerlink" title="我们实现Pascal解释器的语言将会是Python，但是你能够使用任何语言，因为解释器的实现并不依赖于语言的特性。Okay，该开始着手正事了。预备，开始！（翻译者在学习时也使用JAVA再次实现）"></a>我们实现Pascal解释器的语言将会是Python，但是你能够使用任何语言，因为解释器的实现并不依赖于语言的特性。Okay，该开始着手正事了。预备，开始！（翻译者在学习时也使用<code>JAVA</code>再次实现）</h3><h3 id="我们开始解释器和编译器的第一部就是写一个简单的算术表达式的简单解释器，也就是计算器。今天的目标很简单，做一个能够将处理两个单个整数相加的计算器，就想3-5。这里就是计算器的源代码，哦不，是解释器的源代码："><a href="#我们开始解释器和编译器的第一部就是写一个简单的算术表达式的简单解释器，也就是计算器。今天的目标很简单，做一个能够将处理两个单个整数相加的计算器，就想3-5。这里就是计算器的源代码，哦不，是解释器的源代码：" class="headerlink" title="我们开始解释器和编译器的第一部就是写一个简单的算术表达式的简单解释器，也就是计算器。今天的目标很简单，做一个能够将处理两个单个整数相加的计算器，就想3+5。这里就是计算器的源代码，哦不，是解释器的源代码："></a>我们开始解释器和编译器的第一部就是写一个简单的算术表达式的简单解释器，也就是计算器。今天的目标很简单，做一个能够将处理两个单个整数相加的计算器，就想<code>3+5</code>。这里就是计算器的源代码，哦不，是解释器的源代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Token types## EOF (end-of-file) token is used to indicate that# there is no more input left for lexical analysisINTEGER, PLUS, EOF = 'INTEGER', 'PLUS', 'EOF'class Token(object):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, PLUS, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: 0, 1, 2. 3, 4, 5, 6, 7, 8, 9, '+', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.        Examples:            Token(INTEGER, 3)            Token(PLUS '+')        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()<span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3+5"</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        <span class="comment"># current token instance</span></span><br><span class="line">        self.current_token = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Error parsing input'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)        This method is responsible for breaking a sentence        apart into tokens. One token at a time.        """</span></span><br><span class="line">        text = self.text</span><br><span class="line"></span><br><span class="line">        <span class="comment"># is self.pos index past the end of the self.text ?</span></span><br><span class="line">        <span class="comment"># if so, then return EOF token because there is no more</span></span><br><span class="line">        <span class="comment"># input left to convert into tokens</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(text) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># get a character at the position self.pos and decide</span></span><br><span class="line">        <span class="comment"># what token to create based on the single character</span></span><br><span class="line">        current_char = text[self.pos]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># if the character is a digit then convert it to</span></span><br><span class="line">        <span class="comment"># integer, create an INTEGER token, increment self.pos</span></span><br><span class="line">        <span class="comment"># index to point to the next character after the digit,</span></span><br><span class="line">        <span class="comment"># and return the INTEGER token</span></span><br><span class="line">        <span class="keyword">if</span> current_char.isdigit():</span><br><span class="line">            token = Token(INTEGER, int(current_char))</span><br><span class="line">            self.pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> current_char == <span class="string">'+'</span>:</span><br><span class="line">            token = Token(PLUS, current_char)</span><br><span class="line">            self.pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line">        self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""expr -&gt; INTEGER PLUS INTEGER"""</span></span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.get_next_token()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># we expect the current token to be a single-digit integer</span></span><br><span class="line">        left = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># we expect the current token to be a '+' token</span></span><br><span class="line">        op = self.current_token</span><br><span class="line">        self.eat(PLUS)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># we expect the current token to be a single-digit integer</span></span><br><span class="line">        right = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="comment"># after the above call the self.current_token is set to</span></span><br><span class="line">        <span class="comment"># EOF token</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># at this point INTEGER PLUS INTEGER sequence of tokens</span></span><br><span class="line">        <span class="comment"># has been successfully found and the method can just</span></span><br><span class="line">        <span class="comment"># return the result of adding two integers, thus</span></span><br><span class="line">        <span class="comment"># effectively interpreting client input</span></span><br><span class="line">        result = left.value + right.value</span><br><span class="line">        <span class="keyword">return</span> resultdef main():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call</span></span><br><span class="line">            <span class="comment"># with 'input'</span></span><br><span class="line">            text = raw_input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        interpreter = Interpreter(text)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)<span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="将上述代码保存到calc1-py文件或者你可以直接从GitHub上下载。在你准备钻研代码之前，先在命令行上运行，这样你就能看到执行结果。先试试吧！这里是一个在我笔记本上的简单会话（如果你想要使用Python3运行这个计算器，你可能需要将raw-input替换为input）"><a href="#将上述代码保存到calc1-py文件或者你可以直接从GitHub上下载。在你准备钻研代码之前，先在命令行上运行，这样你就能看到执行结果。先试试吧！这里是一个在我笔记本上的简单会话（如果你想要使用Python3运行这个计算器，你可能需要将raw-input替换为input）" class="headerlink" title="将上述代码保存到calc1.py文件或者你可以直接从GitHub上下载。在你准备钻研代码之前，先在命令行上运行，这样你就能看到执行结果。先试试吧！这里是一个在我笔记本上的简单会话（如果你想要使用Python3运行这个计算器，你可能需要将raw_input替换为input）:"></a>将上述代码保存到calc1.py文件或者你可以直接从<a href="https://github.com/rspivak/lsbasi/blob/master/part1/calc1.py" target="_blank" rel="noopener">GitHub</a>上下载。在你准备钻研代码之前，先在命令行上运行，这样你就能看到执行结果。先试试吧！这里是一个在我笔记本上的简单会话（如果你想要使用Python3运行这个计算器，你可能需要将<code>raw_input</code>替换为<code>input</code>）:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python calc1.py</span><br><span class="line">calc&gt; <span class="number">3</span>+<span class="number">4</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">calc&gt; <span class="number">3</span>+<span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line">calc&gt; <span class="number">3</span>+<span class="number">9</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line">calc&gt;</span><br></pre></td></tr></table></figure>
<h3 id="为了确保你的计算器能够正常工作不抛异常，你的输入需要满足一下指定规则："><a href="#为了确保你的计算器能够正常工作不抛异常，你的输入需要满足一下指定规则：" class="headerlink" title="为了确保你的计算器能够正常工作不抛异常，你的输入需要满足一下指定规则："></a>为了确保你的计算器能够正常工作不抛异常，你的输入需要满足一下指定规则：</h3><p>&#8195; ·单个数字作为输入 </p>
<p>&#8195; ·只能运算加法 </p>
<p>&#8195; ·在输入的任何地方不能有空格 </p>
<h3 id="这些限制就能使得计算器的实现变得简单。别担心过，不久我们就能做一个更加复杂更加完善的了。"><a href="#这些限制就能使得计算器的实现变得简单。别担心过，不久我们就能做一个更加复杂更加完善的了。" class="headerlink" title="这些限制就能使得计算器的实现变得简单。别担心过，不久我们就能做一个更加复杂更加完善的了。"></a>这些限制就能使得计算器的实现变得简单。别担心过，不久我们就能做一个更加复杂更加完善的了。</h3><h3 id="好了，现在就让我们看看这个解释器是如何工作并且它是如何进行算数运算的。"><a href="#好了，现在就让我们看看这个解释器是如何工作并且它是如何进行算数运算的。" class="headerlink" title="好了，现在就让我们看看这个解释器是如何工作并且它是如何进行算数运算的。"></a>好了，现在就让我们看看这个解释器是如何工作并且它是如何进行算数运算的。</h3><h3 id="当你在命令行输入-3-5-的时候，解释器就获得了一个字符串-“3-5”。为了使解释器能够理解这一字符串，那么就要将-“3-5”-拆分成不同的个体单元，我们将这些个体称为tokens。一个token是一个拥有类型和值的对象。比如字符-“3”-的类型为整数，而对应的值就为整数-”3“。"><a href="#当你在命令行输入-3-5-的时候，解释器就获得了一个字符串-“3-5”。为了使解释器能够理解这一字符串，那么就要将-“3-5”-拆分成不同的个体单元，我们将这些个体称为tokens。一个token是一个拥有类型和值的对象。比如字符-“3”-的类型为整数，而对应的值就为整数-”3“。" class="headerlink" title="当你在命令行输入 3+5 的时候，解释器就获得了一个字符串 “3+5”。为了使解释器能够理解这一字符串，那么就要将 “3+5” 拆分成不同的个体单元，我们将这些个体称为tokens。一个token是一个拥有类型和值的对象。比如字符 “3” 的类型为整数，而对应的值就为整数 ”3“。"></a>当你在命令行输入 <em>3+5</em> 的时候，解释器就获得了一个字符串 <em>“3+5”</em>。为了使解释器能够理解这一字符串，那么就要将 <em>“3+5”</em> 拆分成不同的个体单元，我们将这些个体称为tokens。一个token是一个拥有类型和值的对象。比如字符 <em>“3”</em> 的类型为整数，而对应的值就为整数 <em>”3“</em>。</h3><h3 id="将这些输入的字符串拆分为tokens的程序就叫词法分析-lexical-analysis-。所以，我们的解释器最先需要的就是读取输入的字符并且将他们转换为tokens的流。解释器的这一部分就叫词法分析器（-lexical-analyzer-）或者词法器（-lexer-）。你可能还看到过这一部分的其他名字，例如-scanner-或者-tokenizer。它们都是一个意思：解释器或编译器中，将输入的字符转换为tokens流的一部分。"><a href="#将这些输入的字符串拆分为tokens的程序就叫词法分析-lexical-analysis-。所以，我们的解释器最先需要的就是读取输入的字符并且将他们转换为tokens的流。解释器的这一部分就叫词法分析器（-lexical-analyzer-）或者词法器（-lexer-）。你可能还看到过这一部分的其他名字，例如-scanner-或者-tokenizer。它们都是一个意思：解释器或编译器中，将输入的字符转换为tokens流的一部分。" class="headerlink" title="将这些输入的字符串拆分为tokens的程序就叫词法分析( lexical analysis)。所以，我们的解释器最先需要的就是读取输入的字符并且将他们转换为tokens的流。解释器的这一部分就叫词法分析器（ lexical analyzer ）或者词法器（ lexer ）。你可能还看到过这一部分的其他名字，例如 scanner 或者 tokenizer。它们都是一个意思：解释器或编译器中，将输入的字符转换为tokens流的一部分。"></a>将这些输入的字符串拆分为tokens的程序就叫词法分析( <strong>lexical analysis</strong>)。所以，我们的解释器最先需要的就是读取输入的字符并且将他们转换为tokens的流。解释器的这一部分就叫词法分析器（ <strong>lexical analyzer</strong> ）或者词法器（ <strong>lexer</strong> ）。你可能还看到过这一部分的其他名字，例如 <strong>scanner</strong> 或者 <strong>tokenizer</strong>。它们都是一个意思：解释器或编译器中，将输入的字符转换为tokens流的一部分。</h3><h3 id="在Interpreter类中的函数方法get-next-token就是词法分析器。每一次调用它，你就会得到下一个从输入的字符里面得到的token，并且传递给解释器。让我们更近一步的看一下这个方法本身，看看它具体是如何将字符转换为tokens的。输入存储在变量-text中，text中包含了字符串以及一个字符串的位置索引的值pos（想象这个字符串是一个字符的数组）。pos的初始化地址为0，并且指向字符-‘3’。这个方法首先确认这个字符是否为数字，如果是的话，那么他就将pos自增1并且返回一个类型为整数的token实例。在这个例子中，字符串-‘3’-就是一个整数-3-。"><a href="#在Interpreter类中的函数方法get-next-token就是词法分析器。每一次调用它，你就会得到下一个从输入的字符里面得到的token，并且传递给解释器。让我们更近一步的看一下这个方法本身，看看它具体是如何将字符转换为tokens的。输入存储在变量-text中，text中包含了字符串以及一个字符串的位置索引的值pos（想象这个字符串是一个字符的数组）。pos的初始化地址为0，并且指向字符-‘3’。这个方法首先确认这个字符是否为数字，如果是的话，那么他就将pos自增1并且返回一个类型为整数的token实例。在这个例子中，字符串-‘3’-就是一个整数-3-。" class="headerlink" title="在Interpreter类中的函数方法get_next_token就是词法分析器。每一次调用它，你就会得到下一个从输入的字符里面得到的token，并且传递给解释器。让我们更近一步的看一下这个方法本身，看看它具体是如何将字符转换为tokens的。输入存储在变量 text中，text中包含了字符串以及一个字符串的位置索引的值pos（想象这个字符串是一个字符的数组）。pos的初始化地址为0，并且指向字符 ‘3’。这个方法首先确认这个字符是否为数字，如果是的话，那么他就将pos自增1并且返回一个类型为整数的token实例。在这个例子中，字符串 ‘3’ 就是一个整数 3 。"></a>在<code>Interpreter</code>类中的函数方法<code>get_next_token</code>就是词法分析器。每一次调用它，你就会得到下一个从输入的字符里面得到的token，并且传递给解释器。让我们更近一步的看一下这个方法本身，看看它具体是如何将字符转换为tokens的。输入存储在变量 <code>text</code>中，<code>text</code>中包含了字符串以及一个字符串的位置索引的值<code>pos</code>（想象这个字符串是一个字符的数组）。<code>pos</code>的初始化地址为0，并且指向字符 <em>‘3’</em>。这个方法首先确认这个字符是否为数字，如果是的话，那么他就将pos自增1并且返回一个类型为整数的token实例。在这个例子中，字符串 <em>‘3’</em> 就是一个整数 <em>3</em> 。</h3><p><img src="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_lexer1.png" alt="integer3"></p>
<h3 id="现在-text中的-pos-的值就指向了字符-‘-’-。下次你调用这个方法的时候，他就会检验位置-pos-指向的字符是否为数字，然后再查询这个字符是否为一个加号标志，当然它是。这个方法的结果，就是自增-pos-并且返回一个新创建的类型为PLUS并且值为-‘-’-的token。"><a href="#现在-text中的-pos-的值就指向了字符-‘-’-。下次你调用这个方法的时候，他就会检验位置-pos-指向的字符是否为数字，然后再查询这个字符是否为一个加号标志，当然它是。这个方法的结果，就是自增-pos-并且返回一个新创建的类型为PLUS并且值为-‘-’-的token。" class="headerlink" title="现在 text中的 pos 的值就指向了字符 ‘+’ 。下次你调用这个方法的时候，他就会检验位置 pos 指向的字符是否为数字，然后再查询这个字符是否为一个加号标志，当然它是。这个方法的结果，就是自增 pos 并且返回一个新创建的类型为PLUS并且值为 ‘+’ 的token。"></a>现在 <em>text</em>中的 <em>pos</em> 的值就指向了字符 <em>‘+’</em> 。下次你调用这个方法的时候，他就会检验位置 <em>pos</em> 指向的字符是否为数字，然后再查询这个字符是否为一个加号标志，当然它是。这个方法的结果，就是自增 <em>pos</em> 并且返回一个新创建的类型为PLUS并且值为 <em>‘+’</em> 的token。</h3><p><img src="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_lexer2.png" alt="plustoken"></p>
<h3 id="pos-现在就指向了字符-‘5’-。当你再次调用get-next-token方法的时候，方法就检查他是否为一个数字，显然是的，所以-pos-自增1且返回一个新的整数token并且将这个token的值设置为整数-5-："><a href="#pos-现在就指向了字符-‘5’-。当你再次调用get-next-token方法的时候，方法就检查他是否为一个数字，显然是的，所以-pos-自增1且返回一个新的整数token并且将这个token的值设置为整数-5-：" class="headerlink" title="pos 现在就指向了字符 ‘5’ 。当你再次调用get_next_token方法的时候，方法就检查他是否为一个数字，显然是的，所以 pos 自增1且返回一个新的整数token并且将这个token的值设置为整数 5 ："></a><em>pos</em> 现在就指向了字符 <em>‘5’</em> 。当你再次调用<code>get_next_token</code>方法的时候，方法就检查他是否为一个数字，显然是的，所以 <em>pos</em> 自增1且返回一个新的整数token并且将这个token的值设置为整数 <em>5</em> ：</h3><p><img src="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_lexer3.png" alt="integer5"></p>
<h3 id="索引-pos-现在已经到了字符串-“3-5”-的最后，每次到这种时候，函数get-next-token就返回一个EOF的token："><a href="#索引-pos-现在已经到了字符串-“3-5”-的最后，每次到这种时候，函数get-next-token就返回一个EOF的token：" class="headerlink" title="索引 pos 现在已经到了字符串 “3+5” 的最后，每次到这种时候，函数get_next_token就返回一个EOF的token："></a>索引 <em>pos</em> 现在已经到了字符串 <em>“3+5”</em> 的最后，每次到这种时候，函数<code>get_next_token</code>就返回一个EOF的token：</h3><p><img src="https://ruslanspivak.com/lsbasi-part1/lsbasi_part1_lexer4.png" alt="tokenEOF"></p>
<h3 id="尝试一下并且看看词法分析器是如何工作的："><a href="#尝试一下并且看看词法分析器是如何工作的：" class="headerlink" title="尝试一下并且看看词法分析器是如何工作的："></a>尝试一下并且看看词法分析器是如何工作的：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> calc1 <span class="keyword">import</span> Interpreter</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter = Interpreter(<span class="string">'3+5'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter.get_next_token()</span><br><span class="line">Token(INTEGER, <span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter.get_next_token()</span><br><span class="line">Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter.get_next_token()</span><br><span class="line">Token(INTEGER, <span class="number">5</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interpreter.get_next_token()</span><br><span class="line">Token(EOF, <span class="literal">None</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="到这里，你的解释器已经能够从输入的字符串里获得tokens流了，解释器就需要去用它进一步处理：他需要从词法分析函数get-next-token获得如下的结构：整数-gt-加号-gt-整数。"><a href="#到这里，你的解释器已经能够从输入的字符串里获得tokens流了，解释器就需要去用它进一步处理：他需要从词法分析函数get-next-token获得如下的结构：整数-gt-加号-gt-整数。" class="headerlink" title="到这里，你的解释器已经能够从输入的字符串里获得tokens流了，解释器就需要去用它进一步处理：他需要从词法分析函数get_next_token获得如下的结构：整数-&gt;加号-&gt;整数。"></a>到这里，你的解释器已经能够从输入的字符串里获得tokens流了，解释器就需要去用它进一步处理：他需要从词法分析函数<code>get_next_token</code>获得如下的结构：整数-&gt;加号-&gt;整数。</h3><h3 id="负责找到并且解释这一数据结构的函数是expr。这个方法验证了输入的token的顺序是否是正确的，比如：整数-gt-加号-gt-整数。在正确验证了数据结构后，他将加号左边和右边的token的值相加，因此就正确解释了你传递给解释器的表达式。"><a href="#负责找到并且解释这一数据结构的函数是expr。这个方法验证了输入的token的顺序是否是正确的，比如：整数-gt-加号-gt-整数。在正确验证了数据结构后，他将加号左边和右边的token的值相加，因此就正确解释了你传递给解释器的表达式。" class="headerlink" title="负责找到并且解释这一数据结构的函数是expr。这个方法验证了输入的token的顺序是否是正确的，比如：整数-&gt;加号-&gt;整数。在正确验证了数据结构后，他将加号左边和右边的token的值相加，因此就正确解释了你传递给解释器的表达式。"></a>负责找到并且解释这一数据结构的函数是<code>expr</code>。这个方法验证了输入的token的顺序是否是正确的，比如：整数-&gt;加号-&gt;整数。在正确验证了数据结构后，他将加号左边和右边的token的值相加，因此就正确解释了你传递给解释器的表达式。</h3><h3 id="函数expr使用了辅助函数eat去验证传递过来的token的类型是否正确，在匹配了token的类型，函数eat获得下一个token并且将他赋值为变量-current-token-。看起来就像是在吞食当前匹配的标记符，并不断将-pos-指向下一个位置。如果token流的顺序与预期不符，则函数eat就会抛出异常。"><a href="#函数expr使用了辅助函数eat去验证传递过来的token的类型是否正确，在匹配了token的类型，函数eat获得下一个token并且将他赋值为变量-current-token-。看起来就像是在吞食当前匹配的标记符，并不断将-pos-指向下一个位置。如果token流的顺序与预期不符，则函数eat就会抛出异常。" class="headerlink" title="函数expr使用了辅助函数eat去验证传递过来的token的类型是否正确，在匹配了token的类型，函数eat获得下一个token并且将他赋值为变量 current_token 。看起来就像是在吞食当前匹配的标记符，并不断将 pos 指向下一个位置。如果token流的顺序与预期不符，则函数eat就会抛出异常。"></a>函数<code>expr</code>使用了辅助函数<code>eat</code>去验证传递过来的token的类型是否正确，在匹配了token的类型，函数<code>eat</code>获得下一个token并且将他赋值为变量 <em>current_token</em> 。看起来就像是在吞食当前匹配的标记符，并不断将 <em>pos</em> 指向下一个位置。如果token流的顺序与预期不符，则函数<code>eat</code>就会抛出异常。</h3><h3 id="让我们复述一下，你的解释器是如何验算一个算术表达式的："><a href="#让我们复述一下，你的解释器是如何验算一个算术表达式的：" class="headerlink" title="让我们复述一下，你的解释器是如何验算一个算术表达式的："></a>让我们复述一下，你的解释器是如何验算一个算术表达式的：</h3><p>&#8195;·解释器获得了一个字符串， <em>“3+5”</em> </p>
<p>&#8195;·解释器调用<code>expr</code>方法去找到一个从词法分析器<code>get_next_token</code>中获得的token流。并且尝试去匹配形式：整型-&gt;加号-&gt;整型。确认了结构后，解释器就将两个整型tokens的值相加，这对于解释器来说就比较清楚了。 </p>
<h3 id="祝贺你自己！你已经学会了构建你的第一个解释器。"><a href="#祝贺你自己！你已经学会了构建你的第一个解释器。" class="headerlink" title="祝贺你自己！你已经学会了构建你的第一个解释器。"></a>祝贺你自己！你已经学会了构建你的第一个解释器。</h3><h3 id="现在是练习时间啦！"><a href="#现在是练习时间啦！" class="headerlink" title="现在是练习时间啦！"></a>现在是练习时间啦！</h3><p><img src="https://ruslanspivak.com/lsbasi-part1/lsbasi_exercises2.png" alt="练习"></p>
<h3 id="你是不是认为仅仅是读了这篇文章还完全不够呢？好吧，让我们来处理一些一下更复杂的情况吧："><a href="#你是不是认为仅仅是读了这篇文章还完全不够呢？好吧，让我们来处理一些一下更复杂的情况吧：" class="headerlink" title="你是不是认为仅仅是读了这篇文章还完全不够呢？好吧，让我们来处理一些一下更复杂的情况吧："></a>你是不是认为仅仅是读了这篇文章还完全不够呢？好吧，让我们来处理一些一下更复杂的情况吧：</h3><p>&#8195;1.改变代码是的输入的字符能够是多位数的数字，例如 <em>“12+3”</em> </p>
<p>&#8195;2. 添加一个方法，能够跳过空格，这样你的解释器就能处理如 <em>“ &#8195;12+3”</em> 的情况啦。 </p>
<p>&#8195;3.改变代码使得运算不仅仅是 <em>”+“</em> 还能处理 <em>”-“</em> 例如 <em>”7-5“</em> </p>
<h2 id="检验你是否理解了呢？"><a href="#检验你是否理解了呢？" class="headerlink" title="检验你是否理解了呢？"></a><strong>检验你是否理解了呢？</strong></h2><p>&#8195;1.解释器是什么？ </p>
<p>&#8195;2.编译器是什么？ </p>
<p>&#8195;3.解释器和编译器之间有什么区别？ </p>
<p>&#8195;4.token是什么？ </p>
<p>&#8195;5.将输入的字符流转换为tokens的程序叫什么名字？ </p>
<p>&#8195;6.解释器中处理文法分析的部件叫什么？ </p>
<p>&#8195;7.解释器和编译器中，第6题的其他通用名是什么？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/01/HB-is-one-of-my-best-friends/" data-id="cjsq858970001m4vbmuav8ejj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/02/28/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/01/HB-is-one-of-my-best-friends/">let&#39;s build a simple interpreter 1(转)(翻)</a>
          </li>
        
          <li>
            <a href="/2019/02/28/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 weiyun98<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/archives" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>